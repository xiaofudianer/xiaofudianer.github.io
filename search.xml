<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Cookie和Session的对比分析]]></title>
      <url>http://xiaoweiwei.space/2016/08/08/Session%E5%92%8Ccookie/</url>
      <content type="html"><![CDATA[<p><img src="http://ol64dqiw0.bkt.clouddn.com/timg.jpg" alt=""><br><strong>对Web开发中的Session和Cookie的一点总结</strong><br><a id="more"></a></p>
<h1 id="会话是什么？"><a href="#会话是什么？" class="headerlink" title="会话是什么？"></a>会话是什么？</h1><pre><code>会话：浏览器从打开开始，即为一个会话的开始。
     一个会话中是存在N次请求。
      浏览器关闭，即视为一个会话的结束。
会话---浏览器
IE浏览器   和  火狐浏览器  分别是两个会话
会话比喻成：打电话
        电话接通，会话开启
        N次的问答交流
        电话挂断，会话结束
</code></pre><h1 id="会话技术是什么？有什么用？"><a href="#会话技术是什么？有什么用？" class="headerlink" title="会话技术是什么？有什么用？"></a>会话技术是什么？有什么用？</h1><pre><code>会话技术就是用来保存会话中产生的数据的。
</code></pre><h1 id="会话技术-保存数据的正常生命周期。"><a href="#会话技术-保存数据的正常生命周期。" class="headerlink" title="会话技术 保存数据的正常生命周期。"></a>会话技术 保存数据的正常生命周期。</h1><pre><code>会话开启时 ---------数据必须都保存起来---------会话结束时
</code></pre><h1 id="会话技术的种类"><a href="#会话技术的种类" class="headerlink" title="会话技术的种类"></a>会话技术的种类</h1><pre><code>保存在客户端的会话技术：   Cookie


保存在服务端的会话技术：   Session
</code></pre><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h1 id="cookie是什么？有什么用？"><a href="#cookie是什么？有什么用？" class="headerlink" title="cookie是什么？有什么用？"></a>cookie是什么？有什么用？</h1><pre><code>Cookie就是服务器写给客户端的一张小纸条。


就是用来传递并存储信息。


这张小纸条，数据是以键值对的形式保存的
</code></pre><h1 id="cookie怎么用？"><a href="#cookie怎么用？" class="headerlink" title="cookie怎么用？"></a>cookie怎么用？</h1><pre><code>服务器如何给客户端写cookie
    Cookie cookie = new Cookie(&quot;cd1hehe&quot;,&quot;zhangsan&quot;);

服务器如果把cookie传递给客户端

    写入响应头
    //已经过时的方法
    response.setHeader(&quot;Set-Cookie&quot;, &quot;cd1hehe=zhangsan&quot;);
    Set-Cookie:cd1hehe=zhangsan


    //response的方法    底层自动帮你写Set-Cookie的响应头
    response.addCookie(cookie);
</code></pre><h1 id="cookie技术的深入"><a href="#cookie技术的深入" class="headerlink" title="cookie技术的深入"></a>cookie技术的深入</h1><pre><code>浏览器只负责接收 cookie，并且存储cookie，把cookie传递给服务器

服务器负责给浏览器写cookie，并且负责接收cookie并且处理cookie

如何将请求头中的cookie信息在服务器中取到？
    Cookie:cd1hehe=zhangsan; cd2=zhangsan; cd3=zhangsan
    request.getHeader(&quot;Cookie&quot;);
    //自动从请求头中获取cookie信息，并且切割并封装成多个cookie对象
    request.getCookies();
    如果请求头中有cookie信息，就获取返回成cookie数组
    如果请求头中没有cookie信息，直接返回null
    火狐中管理cookie操作：
    工具---》选项----》隐私----》移除单个cookie
</code></pre><h1 id="cookie-常用API操作"><a href="#cookie-常用API操作" class="headerlink" title="cookie 常用API操作"></a>cookie 常用API操作</h1><pre><code>Cookie对象
    getName();    返回值String，返回的是cookie的名字
    getValue();   返回值String，返回的是cookie的值
</code></pre><h1 id="cookie的生命周期"><a href="#cookie的生命周期" class="headerlink" title="cookie的生命周期"></a>cookie的生命周期</h1><pre><code>默认情况下：
    会话级别cookie，保存在浏览器的缓存中。
    缓存中的信息，在浏览器关闭时就会销毁。
    会话开启  -----------（cookie存活）----------会话技术
特殊情况：
    持久化cookie，保存在浏览器对应的硬盘上。    
    setMaxAge();    设置最大生存时间，秒  
            -1   会话级别的cookie。默认
            &gt;0   会把cookie持久化保存硬盘上
                如果cookie过期了，浏览器就不会传递这个cookie了
            0     立即过期。  相当于删除一个cookie
</code></pre><hr>
<h1 id="cookie使用的注意事项"><a href="#cookie使用的注意事项" class="headerlink" title="cookie使用的注意事项"></a>cookie使用的注意事项</h1><pre><code>①cookie保存是有限制的。使用时要尽量谨慎，某些功能不得不依赖cookie，再去使用
    大小限制：value 最多保存4kb内容。不能向cookie中存储大数据
    数量限制：一个网站一个项目最多向一个浏览器保存30个cookie。
          一个浏览器从网络上最多接收300个cookie。                     
②cookie不仅仅是javaee技术，asp,php,android
因为cookie是http协议制定
③cookie不能直接存储中文。
</code></pre><hr>
<h1 id="cookie有效路径"><a href="#cookie有效路径" class="headerlink" title="cookie有效路径"></a>cookie有效路径</h1><pre><code>有效路径：浏览器访问什么路径 ，带哪些cookie


setPath(String path);   //设置有效路径


访问路径 不等于或者不包含 cookie有效路径，cookie不会被带过来的

访问路径 等于或者包含 cookie有效路径，cookie是被带过来了



有效路径默认：就是你Servlet的访问路径的所在目录

    例如： /cd3            有效路径:/web16/
           /hehe/cd3       有效路径:/web16/hehe/
</code></pre><h1 id="cookie唯一标识"><a href="#cookie唯一标识" class="headerlink" title="cookie唯一标识"></a>cookie唯一标识</h1><pre><code>cookie的唯一标识如果相同，那么就是同一个cookie，同一个cookie，新的会覆盖旧的
唯一标识：域名+路径+cookie名字
例如：
cookie1:  http://www.baidu.com/hehe/     cd1
cookie2:  http://www.taobao.com/hehe/    cd1
虽然上述两个cookie路径和名字相同，但是域名不同，所以不是一个cookie，会分别保存
cookie1:  http://www.baidu.com/hehe/     cd1
cookie2:  http://www.baidu.com/xixi/     cd1
虽然上述两个cookie域名和名字相同，但是路径不同，所以不是一个cookie，会分别保存
cookie1:  http://www.baidu.com/hehe/     cd1
cookie2:  http://www.baidu.com/hehe/     cd2
虽然上述两个cookie域名和路径相同，但是名字不同，所以不是一个cookie，会分别保存
cookie1:  http://www.baidu.com/hehe/     cd1
cookie2:  http://www.baidu.com/hehe/     cd1
上述两个cookie域名、路径和名字一致的，所以这两个cookie是同一个cookie，会存在覆盖关系
</code></pre><hr>
<h1 id="Session是什么？作用？"><a href="#Session是什么？作用？" class="headerlink" title="Session是什么？作用？"></a>Session是什么？作用？</h1><pre><code>session是保存在服务器端的会话技术

就是为了保存会话中产生的数据

session是javaee的规范，只能在javaee中使用

Session是一个域对象，作用范围：针对一次会话有效
</code></pre><h1 id="session怎么用？"><a href="#session怎么用？" class="headerlink" title="session怎么用？"></a>session怎么用？</h1><pre><code>①获取域对象
    HttpSession session = request.getSession();
②使用域对象
</code></pre><h1 id="如何保证在一次会话中，使用的都是一个session对象。"><a href="#如何保证在一次会话中，使用的都是一个session对象。" class="headerlink" title="如何保证在一次会话中，使用的都是一个session对象。"></a>如何保证在一次会话中，使用的都是一个session对象。</h1><pre><code>用JSESSIONID保证。
jsessionid保存在会话级别的cookie中
</code></pre><h1 id="为什么浏览器关闭了，session对象就换了呢？"><a href="#为什么浏览器关闭了，session对象就换了呢？" class="headerlink" title="为什么浏览器关闭了，session对象就换了呢？"></a>为什么浏览器关闭了，session对象就换了呢？</h1><pre><code>会话级别cookie销毁，原先的jsessionid丢失了，就无法对应之前的session对象。
服务器发现你没有jsessionid，就判断你是第一次来，就会给你再创建一个新的session对象。        
</code></pre><h1 id="getSession-实现步骤。"><a href="#getSession-实现步骤。" class="headerlink" title="getSession()实现步骤。"></a>getSession()实现步骤。</h1><pre><code>调用getSession方法时，首先判断cookie中是否有jsessionid。
如果不存在jsessionid，那么直接创建一个新的session对象返回给你，并且向响应头中写一个新的jsessionid的cookie。【相当于第一次来银行创建账户】

如果存在jsessionid,那么还要尝试从服务器内存中去获取session对象。
如果获取到session对象，直接返回使用。【相当于第二次来银行，用银行卡号操作账户】

如果获取不到session对象，那么直接创建一个新的session对象返回给你，并且向响应头中写一个新的jsessionid的cookie。【创建一个新账户，给一张新卡】
</code></pre><h1 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h1><pre><code>getSession(true); -----&gt;getSession();
getSession(false);-----&gt;如果找不到对应的session对象，返回null  【不常用，了解】
</code></pre><h1 id="session对象的常用API"><a href="#session对象的常用API" class="headerlink" title="session对象的常用API"></a>session对象的常用API</h1><pre><code>String getId();   返回session的  jsessionid    
invalidate();     主动销毁session对象。【相当于主动去银行销户】
          一般是不用。
域对象：
void setAttribite(String name,Object value)
String getAttribute()
void removeAttribute(String name)
</code></pre><h1 id="session生命周期"><a href="#session生命周期" class="headerlink" title="session生命周期"></a>session生命周期</h1><pre><code>创建：第一次调用getSession();
销毁：
    1、主动销毁   invalidate();
    2、服务器非正常关闭 [断电、强制关机重启、Console---&gt;Terminate] 
       【服务器正常关闭，之前的数据还存在的。  stop】

    3、session 30分钟自动过期，过期后销毁
        tomcat/conf/web.xml

          &lt;session-config&gt;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;
           &lt;/session-config&gt;
</code></pre><h1 id="将jssionid持久化保存"><a href="#将jssionid持久化保存" class="headerlink" title="将jssionid持久化保存"></a>将jssionid持久化保存</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">      HttpSession session = request.getSession();</div><div class="line"></div><div class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>,session.getId());</div><div class="line">cookie.setPath(request.getContextPath()+<span class="string">"/"</span>);</div><div class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</div><div class="line">response.addCookie(cookie);</div></pre></td></tr></table></figure>
<pre><code>#虽然火狐浏览器会写两个头，但是保存的jsessionid已经持久化
</code></pre><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26402216&auto=1&height=66"></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[solr搜索组件]]></title>
      <url>http://xiaoweiwei.space/2016/07/23/solr/</url>
      <content type="html"><![CDATA[<p><img src="http://ol64dqiw0.bkt.clouddn.com/solr.jpg" alt=""><br><a id="more"></a></p>
<h1 id="field域类型的思想问题"><a href="#field域类型的思想问题" class="headerlink" title="field域类型的思想问题:"></a>field域类型的思想问题:</h1><pre><code>a. 是否分词: 分词的目的是为了索引
    是: 需要创建索引, 并且分词后有意义
        例如: 名称, 描述
    否: 不需要进行索引 或者是 分词后无意义的域就不进行分词
        例如: 主键id, 身份证号
b. 是否索引: 索引的目的是为了查找,搜索
    是: 需要根据这个域进行查询那么就需要索引
        例如: 名称, 描述.....
    否: 不需要根据这个域进行查询那么就不需要进行索引
        例如: 图片
c. 是否存储: 存储的目的是为了显示出来
    是否存储和是否索引无关, 索引影响的Index, 是否存储影响的Document
    是: 名称, 价格, id等
    否: 描述, 描述内容中含有大量图片文字, 这样如果存储会占用大量的磁盘空间, 不划算.
        如果不存储,在需要的时候可以根据id写一条sql语句来进行查询数据库, 可以把
        描述给取出来
</code></pre><p>在lucene中数字类型是需要分词的, 这个是lucene底层封装的算法的要求, 我们不可以修改,<br>所以定死了必须分词</p>
<h1 id="索引和文档的维护-更新操作"><a href="#索引和文档的维护-更新操作" class="headerlink" title="索引和文档的维护(更新操作):"></a>索引和文档的维护(更新操作):</h1><p>对索引和文档的更新操作是, 根据条件先进行查找, 如果找到了就删除,<br>让后将更新的内容添加到索引和文档的最后的位置</p>
<h1 id="booleanQuery中"><a href="#booleanQuery中" class="headerlink" title="booleanQuery中:"></a>booleanQuery中:</h1><p>注意: 如果查询的时候条件使用单个MUST_NOT   或者多个条件中都是MUST_NOT是无效的</p>
<h1 id="相关度排序"><a href="#相关度排序" class="headerlink" title="相关度排序"></a>相关度排序</h1><p>在创建索引的时候会为每个域分配权重.<br>当查询的时候lucene会自动根据查询的关键字进行计算, 和关键字最匹配的排在最上面,<br>和关键字不太匹配的逐渐排在后面</p>
<h1 id="什么是solr"><a href="#什么是solr" class="headerlink" title="什么是solr"></a>什么是solr</h1><p>solr是apache组织的一个全文检索引擎系统,放到tomcat下可以独立运行, 因为它就是一个系统</p>
<h1 id="solr是干什么用的"><a href="#solr是干什么用的" class="headerlink" title="solr是干什么用的"></a>solr是干什么用的</h1><p>在企业中我们可以使用solr来构建全文检索服务, 将solr部署到tomcat下它就可以独立运行,<br>它对外通过http的形式提供全文检索服务(索引和文档的增删改查)</p>
<h1 id="solr和lucene有什么区别"><a href="#solr和lucene有什么区别" class="headerlink" title="solr和lucene有什么区别?"></a>solr和lucene有什么区别?</h1><p>lucene是全文检索引擎工具包,就是一堆jar包, 我们可以用它来开发自己的全文检索引擎系统<br>solr底层是用lucene来开发的, solr是一个现成的全文检索引擎系统, 放入tomcat下就可以独立运行了.<br>solrHome是solr的家, solrHome中可以有多个solrCore, 一个solrCore就是一个solr的实例.<br>实例和实例之间是相互隔离的, 每个实例都会对外单独提供索引和文档的增删改查服务</p>
<h1 id="solr部署步骤"><a href="#solr部署步骤" class="headerlink" title="solr部署步骤:"></a>solr部署步骤:</h1><p>a) 复制一台新的tomcat, 保证这个tomcat是干净的<br>b) 修改eclipse中tomcat的端口, 防止同时运行两个tomcat, 端口冲突<br>c) 将solr/example/webapps下的solr.war复制到tomcat/webapps下<br>d) 启动tomcat, 目的是为了解压, 启动成功后关闭tomcat, 将solr.war删除<br>e) 复制solr/example/lib/ext下的所有放入, tomcat/webapps/solr/WEb-INF/lib下<br>f) 复制solr/example的solr文件夹到硬盘的根目录,并改名为solrHome<br>g) 将solrHome的路径放入到tomcat/webapps/solr/WEB-INF/web.xml中<br>h) 运行tomcat,部署成功</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h1><ol>
<li>solr中域要先定义后使用,如果没有定义就使用会报错<br>ERROR: [doc=002] unknown field ‘xxxxxxxxxxadsadsfsadfsafdsad’”</li>
<li>solr中必须有主键域id, 如果没有会报错<br>“Document is missing mandatory uniqueKey field: id”,</li>
<li>solr中没有单独的修改方法, 都是根据id进行查找,如果找到了将原有的内容删掉, 将<br>新内容添加进去, 如果没有找到, 这直接添加<h1 id="solr界面根据id删除"><a href="#solr界面根据id删除" class="headerlink" title="solr界面根据id删除:"></a>solr界面根据id删除:</h1> <delete><pre><code>&lt;id&gt;01&lt;/id&gt;
</code></pre> </delete><br> <commit><h1 id="solr界面根据查询删除"><a href="#solr界面根据查询删除" class="headerlink" title="solr界面根据查询删除:"></a>solr界面根据查询删除:</h1> <delete><pre><code>&lt;query&gt;*:*&lt;/query&gt;
</code></pre> </delete> <commit>

</commit></commit></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础知识总结]]></title>
      <url>http://xiaoweiwei.space/2016/06/10/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><img src="http://ol64dqiw0.bkt.clouddn.com/006cR2EKzy6VlbxG8Cr8f&amp;690.png" alt=""><br><a id="more"></a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=25870847&auto=1&height=66"></iframe>

<p><strong>一、基本知识</strong></p>
<h1 id="JDK和JRE的区别"><a href="#JDK和JRE的区别" class="headerlink" title="JDK和JRE的区别"></a>JDK和JRE的区别</h1><p>答：JDK是java语言开发工具包，包含JRE和开发工具（javac.exe等）；JRE是java语言的运行环境，包含JVM和核心类库；JVM是java虚拟机，保证了java的跨平台性。</p>
<h1 id="JVM跨平台吗？"><a href="#JVM跨平台吗？" class="headerlink" title="JVM跨平台吗？"></a>JVM跨平台吗？</h1><p>答：JVM不具有跨平台性，不同的操作系统所对应的JVM不一样。正是因为JVM的不跨平台，才能够使java语言具有跨平台性。</p>
<h1 id="保留字是什么？"><a href="#保留字是什么？" class="headerlink" title="保留字是什么？"></a>保留字是什么？</h1><p>答：保留字是还未使用的关键字，可能在java以后的版本中使用。有goto和const。</p>
<h1 id="java语言的特点？"><a href="#java语言的特点？" class="headerlink" title="java语言的特点？"></a>java语言的特点？</h1><p>答：完全面向对象，跨平台性，开源，简单易学，安全可靠，高性能，分布式处理，多线程，健壮性，多态。</p>
<h1 id="main是关键字吗？"><a href="#main是关键字吗？" class="headerlink" title="main是关键字吗？"></a>main是关键字吗？</h1><p>答：不是的。main是主函数的名字，能够被虚拟机识别，是程序执行的入口。</p>
<h1 id="path和classpath的区别？"><a href="#path和classpath的区别？" class="headerlink" title="path和classpath的区别？"></a>path和classpath的区别？</h1><p>答：path环境变量配置的是可执行文件.exe的执行路径;能够在不同盘符下访问path路径下的可执行文件。Classpath配置的java语言编译后生成的字节码文件的执行路径。</p>
<h1 id="存储-进制"><a href="#存储-进制" class="headerlink" title="存储/进制"></a>存储/进制</h1><p>   计算机最基本的存储单位是：字节（byte）<br>   计算机能直接识别的进制是：二进制</p>
<h1 id="进行运算的时-变量和常量有什么区别"><a href="#进行运算的时-变量和常量有什么区别" class="headerlink" title="进行运算的时,变量和常量有什么区别?"></a>进行运算的时,变量和常量有什么区别?</h1><p>答：变量在运算过程中的值是变化的，可以被多次赋值。常量则是固定的。</p>
<h1 id="标识符的组成？以及命名规则？"><a href="#标识符的组成？以及命名规则？" class="headerlink" title="标识符的组成？以及命名规则？"></a>标识符的组成？以及命名规则？</h1><p>答：标识符有26个字母的大小写，0到9,<em>和$组成。<br>    命名规则：不能使用关键字，不能数字开头，严格区分大小写，要见名知义。<br>    函数名和变量名如果是多个单词组成，第一个单词的首字母小写，其余首字母大写。<br>    类名和接口名如果是多个单词组成，首字母全部大写。<br>    包名全部小写。<br>    常量名全部大写，如果是多个单词，用</em>隔开。</p>
<h1 id="变量数据类型分为哪几种？如何使用变量？"><a href="#变量数据类型分为哪几种？如何使用变量？" class="headerlink" title="变量数据类型分为哪几种？如何使用变量？"></a>变量数据类型分为哪几种？如何使用变量？</h1><p>答：基本数据类型：整形：包括byte、short、int、long。浮点型：包括float、doble。<br>字符型;char;布尔型：boolean。<br>引用数据类型：数组、类、接口。<br>变量需要先定义，再赋值，才能使用。</p>
<h1 id="常量分为哪几种？"><a href="#常量分为哪几种？" class="headerlink" title="常量分为哪几种？"></a>常量分为哪几种？</h1><p>答：自定义常量和字面值常量。自定义常量是我们自己通过final修饰定义的常量。字面值常量包括整数、小数、布尔、字符、字符串。</p>
<h1 id="byte的范围多少？char的范围多少？"><a href="#byte的范围多少？char的范围多少？" class="headerlink" title="byte的范围多少？char的范围多少？"></a>byte的范围多少？char的范围多少？</h1><p>答:byte范围-128到127 。   char范围0到65535.</p>
<h1 id="ASCII码表中-字符-‘0’-‘a’-‘A’-分别对应int类型的值是多少"><a href="#ASCII码表中-字符-‘0’-‘a’-‘A’-分别对应int类型的值是多少" class="headerlink" title="ASCII码表中 字符 ‘0’  , ‘a’ , ‘A’ 分别对应int类型的值是多少."></a>ASCII码表中 字符 ‘0’  , ‘a’ , ‘A’ 分别对应int类型的值是多少.</h1><p>答:0在表中对应的值是48，a对应的是97；A对应的是65.</p>
<h1 id="long是8个字节-float是4个字节-为什么long-比-float小"><a href="#long是8个字节-float是4个字节-为什么long-比-float小" class="headerlink" title="long是8个字节,float是4个字节,为什么long 比 float小?"></a>long是8个字节,float是4个字节,为什么long 比 float小?</h1><p>答：底层采用的运算规则不一样。</p>
<h1 id="以取值范围的大小排列数据的基本类型"><a href="#以取值范围的大小排列数据的基本类型" class="headerlink" title="以取值范围的大小排列数据的基本类型."></a>以取值范围的大小排列数据的基本类型.</h1><p>答：double&gt;float&gt;long&gt;int&gt;char&gt;short&gt;byte</p>
<h1 id="、-、这些运算符内隐含了强制类型转换。"><a href="#、-、这些运算符内隐含了强制类型转换。" class="headerlink" title="+=、-=、这些运算符内隐含了强制类型转换。"></a>+=、-=、这些运算符内隐含了强制类型转换。</h1><h1 id="和—的使用？"><a href="#和—的使用？" class="headerlink" title="++和—的使用？"></a>++和—的使用？</h1><p>答：单独使用的时候，在前在后都一样。<br>    参与运算的时候，在前是先自加或者自减，然后再用这个结果参与运算。在后是先参与运算，再进行自加或者自减。</p>
<h1 id="逻辑或-“-“-和-短路或-“-“有什么区别？"><a href="#逻辑或-“-“-和-短路或-“-“有什么区别？" class="headerlink" title="逻辑或 “ | “ 和 短路或 “ || “有什么区别？"></a>逻辑或 “ | “ 和 短路或 “ || “有什么区别？</h1><p>答：|不管前面的结果是真是假后面的都会运算，||前面为真后面的不参与运算。但是结果是一样的。</p>
<h1 id="逻辑与-“-amp-“-和-短路与-“-amp-amp-“-由什么区别？"><a href="#逻辑与-“-amp-“-和-短路与-“-amp-amp-“-由什么区别？" class="headerlink" title="逻辑与 “ &amp; “ 和 短路与 “ &amp;&amp; “ 由什么区别？"></a>逻辑与 “ &amp; “ 和 短路与 “ &amp;&amp; “ 由什么区别？</h1><p>答：&amp;不管前面的结果是真是假后面的都会运算，&amp;&amp;前面为假后面的不参与运算。但是结果是一样的。</p>
<h1 id="Math-round原理是什么？"><a href="#Math-round原理是什么？" class="headerlink" title="Math.round原理是什么？"></a>Math.round原理是什么？</h1><p>答：先加0.5，然后再取floor值。</p>
<h1 id="生成随机数的方法？"><a href="#生成随机数的方法？" class="headerlink" title="生成随机数的方法？"></a>生成随机数的方法？</h1><p>答：第一种：Random类中的方法；第二种Math.random()方法，生成的是0.0和1.0范围直接的小数。</p>
<h1 id="if…else-和三元表达的区别"><a href="#if…else-和三元表达的区别" class="headerlink" title="if…else..和三元表达的区别"></a>if…else..和三元表达的区别</h1><p>答：能用三元表达式写的就能用if语句写，但是能用if语句写的，三元表达式不一定能写。三元表达式必须要有一个结果。</p>
<h1 id="while、do-while-、for的区别？"><a href="#while、do-while-、for的区别？" class="headerlink" title="while、do while 、for的区别？"></a>while、do while 、for的区别？</h1><p>答：do while语句是先性后判断，while和for先判断后执行。<br>    for循环结束后，其中定义的初始化条件不能再使用。</p>
<h1 id="if和switch区别？"><a href="#if和switch区别？" class="headerlink" title="if和switch区别？"></a>if和switch区别？</h1><p>答：if1.对具体的值进行判断。2.对区间判断。3.对运算结果是boolean类型的表达式进行判断。<br>switch： 1.对具体的值进行判断。2.值的个数通常是固定的  </p>
<h1 id="switch语句的表达式可以放什么？"><a href="#switch语句的表达式可以放什么？" class="headerlink" title="switch语句的表达式可以放什么？"></a>switch语句的表达式可以放什么？</h1><p>答：byte、short、int、char。JDK1.5以后可以使用枚举，1.7之后可以使用String。</p>
<h1 id="死循环的两种写法"><a href="#死循环的两种写法" class="headerlink" title="死循环的两种写法."></a>死循环的两种写法.</h1><p>答：while(true)  和  for（；；）</p>
<h1 id="break和continue的区别"><a href="#break和continue的区别" class="headerlink" title="break和continue的区别"></a>break和continue的区别</h1><p>答：break是完全跳出循环，不再执行循环体的代码。也可以用在switch语句中。Continue是提前结束本次循环，进入下次循环。Return是结束方法。</p>
<h1 id="switch中break可以省略吗？default可以省略吗？"><a href="#switch中break可以省略吗？default可以省略吗？" class="headerlink" title="switch中break可以省略吗？default可以省略吗？"></a>switch中break可以省略吗？default可以省略吗？</h1><p>答：break在最后一个可以省略，其他的不要省略。Default可以省略。</p>
<h1 id="方法重载和方法重写的区别？"><a href="#方法重载和方法重写的区别？" class="headerlink" title="方法重载和方法重写的区别？"></a>方法重载和方法重写的区别？</h1><p>答：方法重载是在同一个类中出现同名方法，参数列表不同，与返回值类型无关。<br>    方法重写是在子父类间，子类出现和父类声明完全相同的方法时，就成为方法重写。重写要求返回值必须相同或者有子父类关系。</p>
<h1 id="方法的注意事项："><a href="#方法的注意事项：" class="headerlink" title="方法的注意事项："></a>方法的注意事项：</h1><p>答:要明确方法的返回值类型，明确方法的参数列表。</p>
<h1 id="方法的调用？"><a href="#方法的调用？" class="headerlink" title="方法的调用？"></a>方法的调用？</h1><p>答：有返回值时可以单独调用，但是没有意义；也可以放在输出语句中；可以赋值给变量。无返回值直接调用即可。</p>
<h1 id="数组的定义格式？"><a href="#数组的定义格式？" class="headerlink" title="数组的定义格式？"></a>数组的定义格式？</h1><p>答：int[] arr =new int[5];int arr[]= new int[5];<br>int[] arr = new int[]{1,5,6,7,…} int[] arr = {23,6,8,9…}<br>二维数组<br>String[][] arr = new String[3][];<br>Syso(arr[0])  打印的结果是null。</p>
<h1 id="数组的默认值？"><a href="#数组的默认值？" class="headerlink" title="数组的默认值？"></a>数组的默认值？</h1><p>答;整形的默认值是0，引用数据类型是null；boolean型的是false。</p>
<h1 id="栈内存和堆内存？"><a href="#栈内存和堆内存？" class="headerlink" title="栈内存和堆内存？"></a>栈内存和堆内存？</h1><p>答：栈内存用于存储局部变量和代码的执行，堆内存中都是new出来的。</p>
<h1 id="数组和集合的区别："><a href="#数组和集合的区别：" class="headerlink" title="数组和集合的区别："></a>数组和集合的区别：</h1><p>（1）长度区别：数组长度是固定的；集合长度可变。<br>（2）存储内容：一个数组只能存储同一种数据类型的元素；集合可以存储不同数据类型的元素。<br>（3）数据类型：数组能够存储基本数据类型，也能够存储引用数据类型；集合只能存储引用数组类型。</p>
<h1 id="数组和集合的转换？"><a href="#数组和集合的转换？" class="headerlink" title="数组和集合的转换？"></a>数组和集合的转换？</h1><p>答：数组转为集合：Arrays.asList(数组)，转为集合后不能添加、删除元素。但是可以修改元素。把基本类型的数组转为集合，把这个数组作为对象存入集合中。<br>集合转为数组：list.toArray().</p>
<h1 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h1><h1 id="局部变量和成员变量的区别："><a href="#局部变量和成员变量的区别：" class="headerlink" title="局部变量和成员变量的区别："></a>局部变量和成员变量的区别：</h1><p>（1）定义位置不同：成员变量定义在类中方法外，局部变量定义在方法内。<br>（2）作用范围不同：成员变量在整个类中有效，局部变量在所在的方法有效。<br>（3）内存位置不同：成员变量随着对象的创建存放在堆内存中，局部变量存放在栈内存中。<br>（4）初始化值不同：成员变量是有默认的初始化的值的；局部变量不赋值不能用。<br>（5）生命周期不同：成员变量随着对象的存在而存在，随着对象的消失而消失；局部变量随着方法的调用而存在，方法调用完毕而消失。</p>
<h1 id="变量的使用顺序？"><a href="#变量的使用顺序？" class="headerlink" title="变量的使用顺序？"></a>变量的使用顺序？</h1><p>答:就近原则。先在局部找，局部找不到在本类中找，本类找不到就去父类找，找不到就编译失败。</p>
<h1 id="类和对象的关系？"><a href="#类和对象的关系？" class="headerlink" title="类和对象的关系？"></a>类和对象的关系？</h1><p>答：类是具有相同或相似一类事物的抽象；对象是类的实例化。</p>
<h1 id="java描述事物最基本的单位？"><a href="#java描述事物最基本的单位？" class="headerlink" title="java描述事物最基本的单位？"></a>java描述事物最基本的单位？</h1><p>答：类</p>
<h1 id="什么叫面向对象？"><a href="#什么叫面向对象？" class="headerlink" title="什么叫面向对象？"></a>什么叫面向对象？</h1><p>答：面向对象是一种思想，它是基于面向过程的，强调的是具备功能的对象，让对象调用方法解决问题。在开发中，要完成特定的功能就去寻找相应的对象，如果找不到就创建对象，使用对象，维护完善对象。<br>自己举例说明：厨师做饭，女朋友洗衣服。。。。。<br>思想特点:1.让复杂的事情简单化；2,更符合人类的思维需求；3.角色从执行者到指挥者。<br>三大特征：封装，继承，多态。</p>
<h1 id="什么是封装？封装的原则？好处？"><a href="#什么是封装？封装的原则？好处？" class="headerlink" title="什么是封装？封装的原则？好处？"></a>什么是封装？封装的原则？好处？</h1><p>答：封装就是把不需要对外暴露的状态信息隐藏在对象内部，不允许外部程序直接访问对象的信息，而是通过该类对外提供公共的访问方式对其访问和操作。<br>原则：（1）将不需要对外暴露的信息隐藏；（2）对外提供公共的访问方式。<br>好处：将变化隔离；提高了安全性；便于使用，提高了重用性。</p>
<h1 id="封装就是私有，对吗？为什么？"><a href="#封装就是私有，对吗？为什么？" class="headerlink" title="封装就是私有，对吗？为什么？"></a>封装就是私有，对吗？为什么？</h1><p>答：private是封装的一种体现形式。方法也是封装。</p>
<h1 id="Java中参数传递的问题："><a href="#Java中参数传递的问题：" class="headerlink" title="Java中参数传递的问题："></a>Java中参数传递的问题：</h1><p>答：如果是基本数据类型，传递的参数要和形参的类型一致；如果是引用数据类型，那么传递的参数类型和形参的一致，或者是他的子类。</p>
<h1 id="构造方法，set方法都可以给成员变量赋值，这两种赋值方式有什么区别？"><a href="#构造方法，set方法都可以给成员变量赋值，这两种赋值方式有什么区别？" class="headerlink" title="构造方法，set方法都可以给成员变量赋值，这两种赋值方式有什么区别？"></a>构造方法，set方法都可以给成员变量赋值，这两种赋值方式有什么区别？</h1><p>答：构造方法主要作用是用来给对象初始化，赋值只是他的兼职工作，也可以不用赋值。<br>    Set方法只能用来赋值，在原有对象的基础上赋值。</p>
<h1 id="static关键字的特点？注意事项是什么？有什么好处和弊端？"><a href="#static关键字的特点？注意事项是什么？有什么好处和弊端？" class="headerlink" title="static关键字的特点？注意事项是什么？有什么好处和弊端？"></a>static关键字的特点？注意事项是什么？有什么好处和弊端？</h1><p>答：（1）被static修饰的变量和方法随着类的加载而加载（2）优于对象存在（3）能够被类名直接调用（4）资源共享。<br>注意事项：静态方法中不可以定义this、super关键字，因为静态优先于对象存在，静态只能覆盖静态。<br>好处：static能够被类名直接调用，定义的是对象的共性内容，不用每个对象单独定义，节省空间。弊端：生命周期过长。</p>
<h1 id="类变量和实例变量的区别？"><a href="#类变量和实例变量的区别？" class="headerlink" title="类变量和实例变量的区别？"></a>类变量和实例变量的区别？</h1><p>答：（1）所属不同：类变量属于类，是对象的共性内容；实例变量属于对象，是特性内容。<br>（2）存储位置不同：类变量随着类的加载存储于方法区；实例变量随着对象的创建存储于堆内存中。<br>（3）生命周期不同：类变量随着类的加载而存在，随着类的消失而消失；实例变量随着对象的存在而存在，随着对象的消失而消失。<br>（4）调用方式不同：类变量能够被类名直接调用，有对象的时候也能被对象调用；实例变量只能被对象调用。</p>
<h1 id="构造方法能不能重载？"><a href="#构造方法能不能重载？" class="headerlink" title="构造方法能不能重载？"></a>构造方法能不能重载？</h1><p>答：可以，在同一个类中，参数列表不同，与返回值无关。</p>
<h1 id="静态代码块和构造代码块的区别？"><a href="#静态代码块和构造代码块的区别？" class="headerlink" title="静态代码块和构造代码块的区别？"></a>静态代码块和构造代码块的区别？</h1><p>答：（1）静态代码块属于类，给类进行初始化，类一加载就会执行，只执行一次，经常用于加载驱动。<br>（2）构造代码块给对象进行统一初始化，每创建一次就会执行一次。</p>
<h1 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a>什么是继承？</h1><p>答：当多个类中有很多共性的内容时，我们可以把这些共性内容抽取出来封装成一个类，让这些类与这个封装的类产生关系。这种关系就是继承。</p>
<h1 id="继承的的特点和好处，弊端？"><a href="#继承的的特点和好处，弊端？" class="headerlink" title="继承的的特点和好处，弊端？"></a>继承的的特点和好处，弊端？</h1><p>答：特点：java只支持单继承，但是能够多层次继承；接口能够单继承，也能够多继承。<br>好处：（1）提高了代码的复用性（2）提高了代码的维护性（3）提高了代码的扩展性。（4）让类与类产生了关系，是多态的前提。<br>弊端：增强了类与类的耦合性。</p>
<h1 id="this和super-的区别？"><a href="#this和super-的区别？" class="headerlink" title="this和super 的区别？"></a>this和super 的区别？</h1><p>答：this代表对象的引用，super代表当前对象父类的引用。</p>
<h1 id="Super（）和this（）在构造方法能同时使用吗？"><a href="#Super（）和this（）在构造方法能同时使用吗？" class="headerlink" title="Super（）和this（）在构造方法能同时使用吗？"></a>Super（）和this（）在构造方法能同时使用吗？</h1><p>答 ：不能，super调用的是父类的构造，要放在构造函数的第一行；this调用的是本类的构造，也要放在第一行。</p>
<p>Super关键字和this关键字能否在构造函数中共存？<br>答：能。</p>
<h1 id="为什么每个构造函数中第一行都有默认的super"><a href="#为什么每个构造函数中第一行都有默认的super" class="headerlink" title="为什么每个构造函数中第一行都有默认的super()?"></a>为什么每个构造函数中第一行都有默认的super()?</h1><p>用于子类对象访问父类前，对父类数据进行初始化。</p>
<h1 id="为什么默认的super-都是空参的呢？"><a href="#为什么默认的super-都是空参的呢？" class="headerlink" title="为什么默认的super()都是空参的呢？"></a>为什么默认的super()都是空参的呢？</h1><p>因为Object类是所有 类的父类，Object中只有一个空参构造。</p>
<h1 id="构造方法的特点？"><a href="#构造方法的特点？" class="headerlink" title="构造方法的特点？"></a>构造方法的特点？</h1><p>答：（1）方法名和类名相同（2）没有返回值，连viod都没有。（3）不用写return，可以有return;</p>
<h1 id="this的作用？"><a href="#this的作用？" class="headerlink" title="this的作用？"></a>this的作用？</h1><p>答：（1）区别局部变量和成员变量（2）代表本类对象的引用（3）也可以用于构造方法的调用。</p>
<h1 id="子父类都有静态代码块，构造代码块，构造方法的执行顺序？"><a href="#子父类都有静态代码块，构造代码块，构造方法的执行顺序？" class="headerlink" title="子父类都有静态代码块，构造代码块，构造方法的执行顺序？"></a>子父类都有静态代码块，构造代码块，构造方法的执行顺序？</h1><p>答：父类的静态代码块先执行，再执行子类中的静态代码块；接着执行父类的构造代码块和父类的构造方法，最后执行子类的构造代码块和构造方法。</p>
<h1 id="final修饰的变量的初始化时机："><a href="#final修饰的变量的初始化时机：" class="headerlink" title="final修饰的变量的初始化时机："></a>final修饰的变量的初始化时机：</h1><p>答：a.未被static关键字修饰</p>
<pre><code>* 可以显示初始化
* 可以在构造方法中初始化
</code></pre><p>b.被static修饰</p>
<pre><code>* 可以显示初始化
* 可以在静态代码块中初始化
* 不能在构造方法中初始化
</code></pre><h1 id="final如果修饰局部变量，会发生什么事情？"><a href="#final如果修饰局部变量，会发生什么事情？" class="headerlink" title="final如果修饰局部变量，会发生什么事情？"></a>final如果修饰局部变量，会发生什么事情？</h1><p>答：基本类型，是值不能被改变，引用类型，是地址值不能被改变,对象中的属性可以改变。</p>
<h1 id="什么是多态？多态的体现，前提，好处和弊端分别是什么？"><a href="#什么是多态？多态的体现，前提，好处和弊端分别是什么？" class="headerlink" title="什么是多态？多态的体现，前提，好处和弊端分别是什么？"></a>什么是多态？多态的体现，前提，好处和弊端分别是什么？</h1><p>答：同一事物在不同时刻表现出来的不同状态。<br>体现：父类引用指向子类对象，父类引用作为参数可以接收其子类对象，接口引用作为参数可以接收其实现类对象。<br>前提：（1）类与类之间要有关系，要么继承，要么实现（2）要有方法重写（3）父类或者接口引用指向子类对象。<br>好处：（1）提高了代码的维护性（2）提高了代码的扩展性，父类引用指向子类对象<br>弊端：父类引用只能调用父类的方法，不能调用子类特有的方法和属性。</p>
<p><em>向上转型：父类或者父接口指向子类对象。
</em>向下转型：把那个引用强制转为子类对象。</p>
<h1 id="多态中成员方法和变量的特点？"><a href="#多态中成员方法和变量的特点？" class="headerlink" title="多态中成员方法和变量的特点？"></a>多态中成员方法和变量的特点？</h1><p>答：（1）一般方法：编译看左边，运行看右边。（2）静态方法：编译看左边，运行看左边。（3）变量：编译看左边，运行看左边。</p>
<h1 id="抽象类和抽象方法的特点，有什么关系？"><a href="#抽象类和抽象方法的特点，有什么关系？" class="headerlink" title="抽象类和抽象方法的特点，有什么关系？"></a>抽象类和抽象方法的特点，有什么关系？</h1><p>答：抽象类不能创建对象，需要子类继承；抽象方法没有方法体，需要子类去实现。抽象类不一定含有抽象方法，抽象方法一定在抽象类中。</p>
<h1 id="抽象类中的抽象方法和非抽象方法的区别？"><a href="#抽象类中的抽象方法和非抽象方法的区别？" class="headerlink" title="抽象类中的抽象方法和非抽象方法的区别？"></a>抽象类中的抽象方法和非抽象方法的区别？</h1><p>答：抽象方法要求子类必须重写，完成相应的功能；非抽象方法让子类继承，提高代码的复用性。</p>
<h1 id="abstract不能和哪些关键字共同存在？"><a href="#abstract不能和哪些关键字共同存在？" class="headerlink" title="abstract不能和哪些关键字共同存在？"></a>abstract不能和哪些关键字共同存在？</h1><p>答：private：私有的方法是不可见的，无法被复写<br>    final：被final修饰的方法是最终方法，无法被复写<br>    static：被static修饰的方法，要随类加载到方法区，由于抽象方法没有方法体所以不能加载</p>
<h1 id="final修饰的变量、方法、和类有什么特点？"><a href="#final修饰的变量、方法、和类有什么特点？" class="headerlink" title="final修饰的变量、方法、和类有什么特点？"></a>final修饰的变量、方法、和类有什么特点？</h1><p>答：final修饰的变量只能赋值一次，不能发生改变，如果修饰的基本类型，是其值不能发生改变，如果修饰的引用数据类型，是地址值不能发生改变；final修饰的方法不能被重写；final修饰的类不能被继承，也称最终类。</p>
<h1 id="final、finally、finalized的区别？"><a href="#final、finally、finalized的区别？" class="headerlink" title="final、finally、finalized的区别？"></a>final、finally、finalized的区别？</h1><p>答：（1）final是一个关键字，是用来修饰类，成员变量，成员方法的，<br>    它修饰的类不能被继承，但是可以继承其他类，<br>    它修饰的成员变量是一个常量，只能赋值一次<br>    它修饰的成员方法不能被子类重写<br>（2）finally是 try-catch-finally语句的一个模块，正常情况下里边的代码永远会执行，一般是用来释放资源的<br>（3）finalize是Object类中的方法，当对象变成垃圾的时候，由GC(Java中的垃圾回收机制)来调用该类的finalize()方法回收垃圾。</p>
<h1 id="接口中的成员的特点？"><a href="#接口中的成员的特点？" class="headerlink" title="接口中的成员的特点？"></a>接口中的成员的特点？</h1><p>答：都是常量，public static final ;方法都是抽象方法，public abstract;没有构造方法。</p>
<h1 id="类与类、类与接口、接口与接口的关系？"><a href="#类与类、类与接口、接口与接口的关系？" class="headerlink" title="类与类、类与接口、接口与接口的关系？"></a>类与类、类与接口、接口与接口的关系？</h1><p>答：类只能单继承类，但是能够多层次继承；类实现接口，能同时实现多个接口，能在继承类的同时实现接口；接口可以单继承接口，也能多继承。</p>
<h1 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h1><p>（1）成员的特点：抽象类可以有变量、常量、构造方法、一般方法、抽象方法；接口有且只能有常量和抽象方法。<br>（2）关系特点：类与类支持单继承，不能多继承，但是能够多层次继承，类与接口是实现关系，一个类能实现多个接口，一个类继承类一个类的同时能实现多个接口；接口与接口之间能单继承，也能多继承；<br>（3）设计理念：抽象类定义的是该继承体系的共性功能，是is a的关系。接口定义的是该体系的拓展功能，是like a的关系。</p>
<h1 id="接口的思想特点？"><a href="#接口的思想特点？" class="headerlink" title="接口的思想特点？"></a>接口的思想特点？</h1><p>（1）对外暴露的规则（2）接口是程序对外的功能拓展（3）接口是用来多实现的（4）接口的出现降低了类与类之间的耦合性。</p>
<h1 id="什么是内部类，特点是什么？"><a href="#什么是内部类，特点是什么？" class="headerlink" title="什么是内部类，特点是什么？"></a>什么是内部类，特点是什么？</h1><p>答：在类中定义的类就是内部类。特点（1）能够直接访问所在类的成员，包括私有的。（2）外部类访问内部类需要创建内部类的对象。</p>
<h1 id="成员内部类是什么？"><a href="#成员内部类是什么？" class="headerlink" title="成员内部类是什么？"></a>成员内部类是什么？</h1><p>答：成员内部类是定义在成员位置的类。能够被私有、静态修饰。</p>
<h1 id="内部类的方法如果访问局部变量，内部类的成员变量，外部类的成员变量？"><a href="#内部类的方法如果访问局部变量，内部类的成员变量，外部类的成员变量？" class="headerlink" title="内部类的方法如果访问局部变量，内部类的成员变量，外部类的成员变量？"></a>内部类的方法如果访问局部变量，内部类的成员变量，外部类的成员变量？</h1><p>答：局部变量可以直接访问；内部类的成员变量this.   ；外部类的成员变量：外部类名.this.</p>
<h1 id="局部内部类访问的局部变量为什么要用final修饰？"><a href="#局部内部类访问的局部变量为什么要用final修饰？" class="headerlink" title="局部内部类访问的局部变量为什么要用final修饰？"></a>局部内部类访问的局部变量为什么要用final修饰？</h1><p>答：因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用。但是JDK1.8以后取消了这个特性，会默认加上final的。</p>
<h1 id="什么是匿名内部类？"><a href="#什么是匿名内部类？" class="headerlink" title="什么是匿名内部类？"></a>什么是匿名内部类？</h1><p>答:匿名内部类就是没有名字的内部类，是内部类的简化形式。匿名内部类必须继承或实现一个接口，在使用的时候直接用父类的名字创建一个子类对象并实现其中的方法，匿名内部类的实质是一个继承了该类或者实现该接口的匿名的子类对象。<br>前提：必须继承一个类或实现一个接口。<br>规则：（1）不能是抽象的，因为它的本质是一个子类对象。（2）不能定义构造方法，因为没有类名。<br>使用：（1）当接口中的只有一个抽象方法时，并对方法调用一次的时候（2）传递参数的时候，如果参数是接口或抽象类，其实需要的就是实现类对象或者子类对象，这个时候使用匿名内部类。</p>
<h1 id="匿名对象何时使用？"><a href="#匿名对象何时使用？" class="headerlink" title="匿名对象何时使用？"></a>匿名对象何时使用？</h1><p>答：（1）当对对象方法调用一次的时候（2）可以作为实际参数进行传递。</p>
<h1 id="适配器模式？"><a href="#适配器模式？" class="headerlink" title="适配器模式？"></a>适配器模式？</h1><p>当一个接口有多个抽象方法时，而我们只使用其中的一个或两个方法时，每次使用的时候我们都要重写这些方法，比较麻烦。我们可以定义一个类去实现这个接口，并重写里面的方法，只是方法体为空，并把这个类定义为抽象类，我们使用的时候继承这个类重写需要的方法就就可以了。</p>
<h1 id="四种权限修饰符的比较？"><a href="#四种权限修饰符的比较？" class="headerlink" title="四种权限修饰符的比较？"></a>四种权限修饰符的比较？</h1><p>答：public的权限最大，同一类中，同一个包中，不同包中（子类），不同包中（无关类）都可以访问。  给大家使用<br>Protected同一类中，同一个包中，不同包中（子类），可以访问。强调的是子类<br>默认     同一类中，同一个包中 可以访问。  强调的是同一个包<br>Private   同一类中访问。 强调的是自己</p>
<h1 id="package在第一行，只能有一个；然后是import导包；最后是class。"><a href="#package在第一行，只能有一个；然后是import导包；最后是class。" class="headerlink" title="package在第一行，只能有一个；然后是import导包；最后是class。"></a>package在第一行，只能有一个；然后是import导包；最后是class。</h1><h1 id="代码块的分类："><a href="#代码块的分类：" class="headerlink" title="代码块的分类："></a>代码块的分类：</h1><p>局部代码块：让变量尽早的消失，节约资源，提高效率。<br>构造代码块：用于给对象初始化；<br>静态代码块儿：给类进行初始化，用于加载驱动。<br>同步代码块：为了防止CPU高速切换出现安全问题。</p>
<h1 id="三、API"><a href="#三、API" class="headerlink" title="三、API"></a>三、API</h1><h1 id="和equals的区别？"><a href="#和equals的区别？" class="headerlink" title="==和equals的区别？"></a>==和equals的区别？</h1><p>答：“==”是比较运算符，既能比较基本数据类型，又能比较引用数据类型。基本数据类型比较的是数值，引用数据类型比较的是地址值。<br>equals是一个方法，只能比较引用数据类型。所有的类都会继承Object的equals方法。重写equals方法比较的是对象的内容，如果没有重写将调研Object的equals方法，比较的是地址值。</p>
<h1 id="String-str-null-和String-str-“”的区别？"><a href="#String-str-null-和String-str-“”的区别？" class="headerlink" title="String str = null 和String str = “”的区别？"></a>String str = null 和String str = “”的区别？</h1><p>答：String str = null只是声明了引用，但是没有创建对象，没有为其开辟空间，不能操作方法。String = “”是创建了一个长度为0的字符串，并在内存中分配了空间。</p>
<h1 id="String-s1-“abc”-String-s2-new-String-“abc”-s1-s2结果是什么？s1-equals-s2-结果是什么？"><a href="#String-s1-“abc”-String-s2-new-String-“abc”-s1-s2结果是什么？s1-equals-s2-结果是什么？" class="headerlink" title="String s1= “abc”, String s2= new String(“abc”),s1==s2结果是什么？s1.equals(s2)结果是什么？"></a>String s1= “abc”, String s2= new String(“abc”),s1==s2结果是什么？s1.equals(s2)结果是什么？</h1><p>答：s1==s2结果为false。s1指向的常量池中的对象，s2指向的是堆内存中的对象，两者的地址值不同。s1.equals(s2)结果是true。String重写了equals方法，比较的是内容。</p>
<h1 id="String，StringBuffer、StringBuilder的区别？"><a href="#String，StringBuffer、StringBuilder的区别？" class="headerlink" title="String，StringBuffer、StringBuilder的区别？"></a>String，StringBuffer、StringBuilder的区别？</h1><p>答: String是一个特殊的引用数据类型，是一个长度不可变的字符序列，没有缓冲区，一旦创建就不会发生变化了。即使重新赋值不是在原来对象的基础上改变的，而是创建了一个新的对象，将引用指向这个新的对象，浪费空间，效率比较低。<br>StringBuffer、StringBuilder是容器，是可变的字符串序列。StringBuffer是JDK1.0版本的，线程是安全的，效率比较低。StringBuilder是JDK1.5出现的，线程不安全，效率高。</p>
<h1 id="StringBuilder的底层是什么？"><a href="#StringBuilder的底层是什么？" class="headerlink" title="StringBuilder的底层是什么？"></a>StringBuilder的底层是什么？</h1><p>答：底层是字符数组，原始长度为16。通过append添加元素的时候，会自动扩容，扩容规则：大字符串的长度= 小数组长度*2+2.</p>
<h1 id="为什么出现基本数据类型包装类？"><a href="#为什么出现基本数据类型包装类？" class="headerlink" title="为什么出现基本数据类型包装类？"></a>为什么出现基本数据类型包装类？</h1><p>答：将基本数据类型封装为对象的好处能在对象中封装更多的功能操作数据。</p>
<h1 id="String-和int直接的转换？"><a href="#String-和int直接的转换？" class="headerlink" title="String 和int直接的转换？"></a>String 和int直接的转换？</h1><p>答：将int类型转为String类型的方法：（1）基本数据类型+“”（2）Integer.toString（int num）（3）String.valueOf（int  i）<br>将String转为int：Integer.parseInt(String s)</p>
<h1 id="基本数据类型包装类的自动拆装箱是什么？"><a href="#基本数据类型包装类的自动拆装箱是什么？" class="headerlink" title="基本数据类型包装类的自动拆装箱是什么？"></a>基本数据类型包装类的自动拆装箱是什么？</h1><p>答：是JDK1.5版本出现的新特性，自动装箱就是把基本数据类型转为为包装类型。拆箱就是把包装类转换为基本数据类型。</p>
<h1 id="Object类中的常见方法有哪些？"><a href="#Object类中的常见方法有哪些？" class="headerlink" title="Object类中的常见方法有哪些？"></a>Object类中的常见方法有哪些？</h1><p>答：hashCode():返回值是int，是该对象的哈希玛值。<br>    equals():返回值是boolean，比较的是地址值。<br>    toString():返回该对象的字符串表现形式。<br>    getClass():返回值类型是Class。返回的是创建该对象所属类对应的字节码文件。<br>这些方法都需要对象调用，在开发的过程中要重写。<br>地址值的组成：类名@十六进制的哈希值。</p>
<h1 id="获取当前时间毫秒值有哪几种方式？"><a href="#获取当前时间毫秒值有哪几种方式？" class="headerlink" title="获取当前时间毫秒值有哪几种方式？"></a>获取当前时间毫秒值有哪几种方式？</h1><p>答：（1）new Date().getTime();（2）System. currentTimeMillis()（3）Calendar.getInstance().getTimeInMillis()</p>
<h1 id="正则表达式常用的"><a href="#正则表达式常用的" class="headerlink" title="正则表达式常用的;"></a>正则表达式常用的;</h1><p>\d 数字：[0-9]<br>\w 单词字符：[a-zA-Z_0-9]<br>(X)表示分组<br>\1表示和前面的相同<br>. 任何字符</p>
<p>X? ，一次或一次也没有<br>X* ，零次或多次<br>X+ ，一次或多次<br>X{n} ，恰好 n 次<br>X{n,} ，至少 n 次<br>X{n,m} ，至少 n 次，但是不超过 m 次</p>
<h1 id="日历类和日期类相互转换："><a href="#日历类和日期类相互转换：" class="headerlink" title="日历类和日期类相互转换："></a>日历类和日期类相互转换：</h1><p>Calendar c = Calendar.getInstance();  c.setTime(date);  c.getTime()</p>
<h1 id="Date和String类型的转换？"><a href="#Date和String类型的转换？" class="headerlink" title="Date和String类型的转换？"></a>Date和String类型的转换？</h1><p>Date类型转为String 是格式化：format<br>String转Date是解析；parse</p>
<h1 id="三、集合"><a href="#三、集合" class="headerlink" title="三、集合"></a>三、集合</h1><h1 id="简述集合体系？"><a href="#简述集合体系？" class="headerlink" title="简述集合体系？"></a>简述集合体系？</h1><p>答：集合分为单列集合和双列集合。<br>单列集合的顶层是Collection接口，包括List和Set集合。<br>（1.1）List集合的特点是元素可重复，有序，有索引，能够有角标操作集合，有特有的迭代方式ListIterator。包括ArrayList、LinkedList和Vector。<br>ArrayList集合底层采用的是数组数据结构，查询速度比较快，因为数组有索引，在内存中分配的空间是连续的，但是增删比较慢。线程不同步，效率高。初始容量为10。<br>LinkedList集合的底层采用的是链表数据结构，增删速度比较快，查询速度比较慢。线程不同步。<br>Vector底层数据结构也是数组数据结构，但是线程同步，效率低，特有取出元素的方式是枚举。因为效率低，逐步被ArrayList替代。<br>（1.2） Set集合的特点元素是无序的（存入和取出的顺序不一致），元素不可以重复。包括HashSet和TreeSet。<br>    HashSet的底层数据结构是哈希表，线程不同步，效率高。保证元素的唯一性额有的依据是元素的hashCode和equals方法。如果hashCode不同，不调用equals方法。如果hashCode相同，才会调用equals方法判断元素是否相同。<br>    TreeSet的底层数据结构是二叉树，线程不同步，效率高。能够给元素进行排序。保证元素唯一性的依据是compareTo和return0。排序的两种方式：第一种元素自身实现Comparable接口，重写compareTo（）方法。这种排序方式叫元素的自热排序，也叫默认排序。第二种是当元素自身不具备比较性或者具备的比较性不是所需要的，这时就让集合自身具备比较性，当集合初始化时就有了比较性。定义一个比较器实现Comparator接口，重写compare方法，定义集合的时候将比较器作为参数传递给TreeSet的构造函数，这样集合就具有了比较性。<br>（2）Map是双列集合的顶层接口，该集合存储的是键值对，一对一对的往里存，而且要保证键的唯一性。包括Hashtable、HashMap、TreeMap。<br>    Hashtable的底层数据结构是哈希表，不可以存储null键和null值，线程同步，效率低。JDK1.0.<br>    HashMap的底层数据结构是哈希表，可以存储null键和null值，线程不同步，将Hashtable替代，JDK1.2效率高。保证键的唯一性的 依据是hashCode和equals方法。<br>    TreeMap的底层数据结构是二叉树，线程不安全，能够给集合中的键排序。</p>
<h1 id="什么时候使用什么集合？"><a href="#什么时候使用什么集合？" class="headerlink" title="什么时候使用什么集合？"></a>什么时候使用什么集合？</h1><p>答：（1）首先要看是单列还是双列，是单列的话就用Collection，双列就用Map。<br>（2）要是单列的话看元素是不是要求重复，元素重复的话使用List，看查询多还是增删多，查询多的话用ArrayList，增删多的话用LinkedList，不确定的话用ArrayList。不重复的话使用Set，看是否要求排序，排序的话用TreeSet，不需要排序用HashSet。不确定的话用HashSet。<br>（3）要是双列的话，看是否要求排序，要求排序用TreeMap，不要求排序用HashMap，不确定的话用HashMap。</p>
<h1 id="Collection（单列）和（Map）双列的区别？"><a href="#Collection（单列）和（Map）双列的区别？" class="headerlink" title="Collection（单列）和（Map）双列的区别？"></a>Collection（单列）和（Map）双列的区别？</h1><p>答：Collection是单列集合，Map是双列集合。Map的键是唯一的，Collection体系中的Set集合中的元素是唯一的。Map集合的数据结构针对键有效，Collection的底层数据结构针对元素有效。</p>
<h1 id="遍历集合的方式有哪些？"><a href="#遍历集合的方式有哪些？" class="headerlink" title="遍历集合的方式有哪些？"></a>遍历集合的方式有哪些？</h1><p>答：遍历List集合的方式有普通for、增强for、迭代器Iterator、列表迭代器ListIterator。<br>遍历Set集合的方式有增强for、迭代器Iterator。<br>遍历map集合的方式有keySet（），entrySet（）。然后通过增强for、迭代器Iterator遍历。</p>
<h1 id="用迭代器和增强for遍历集合，能否用集合的方法操作集合？"><a href="#用迭代器和增强for遍历集合，能否用集合的方法操作集合？" class="headerlink" title="用迭代器和增强for遍历集合，能否用集合的方法操作集合？"></a>用迭代器和增强for遍历集合，能否用集合的方法操作集合？</h1><p>答：不能，会出现并发修改异常，ConcurrentModificationException。<br>并发修改异常就是在用普通迭代器的时候用集合的方法增加、删除元素。可以用列表迭代器。</p>
<h1 id="泛型是什么？有什么好处？"><a href="#泛型是什么？有什么好处？" class="headerlink" title="泛型是什么？有什么好处？"></a>泛型是什么？有什么好处？</h1><p>答：简单的说一种标签，不确定的类型，用户使用的时候确定类型，是JDK1.5出现的新特性，用于解决安全问题，是一种类型安全机制。<br>好处：（1）将运行时期会可能出现的异常转移到编译期（2）提高了安全性。（3）避免了强制类型转换的麻烦。</p>
<h1 id="上限和下限？"><a href="#上限和下限？" class="headerlink" title="上限和下限？"></a>上限和下限？</h1><p>？ super E：  E、E的父类，固定下边界。<br>？ extends E： E、E的子类  固定的上边界。</p>
<h1 id="字典排序，自然排序和比较器排序是什么？"><a href="#字典排序，自然排序和比较器排序是什么？" class="headerlink" title="字典排序，自然排序和比较器排序是什么？"></a>字典排序，自然排序和比较器排序是什么？</h1><p>答：字典排序按照字典上的顺序排序。<br>    自然排序是对强制对实现Comparable接口的类进行排序，实现Comparable接口，重写compareTo（）方法，根据返回值进行排序。<br>    比较器排序是实现Comparator方法，重写compare（）方法，根据返回值进行排序。</p>
<h1 id="TreeSet的两种排序方式有什么区别？"><a href="#TreeSet的两种排序方式有什么区别？" class="headerlink" title="TreeSet的两种排序方式有什么区别？"></a>TreeSet的两种排序方式有什么区别？</h1><p>答：TreeSet的构造方法中不传参数，会按照类的Comparable排序，没有的话就会报错。TreeSet传入比较器，会按照比较器排序。</p>
<h1 id="Map有哪些取出元素的方式？原理是什么？"><a href="#Map有哪些取出元素的方式？原理是什么？" class="headerlink" title="Map有哪些取出元素的方式？原理是什么？"></a>Map有哪些取出元素的方式？原理是什么？</h1><p>答：keySet（）：将Map集合中的键取出放在Set集合，然后通过遍历Set集合取出里面的键，再用map的get（key）方法取出对应的值。<br>entrySet（）将Map集合中的键值对关系取出放在Set集合，然后通过遍历Set集合取出里面的键值对关系，然后通过entry的getKey（）和getValue（）方法取出元素。</p>
<h1 id="Collections-和-collection的区别？"><a href="#Collections-和-collection的区别？" class="headerlink" title="Collections 和 collection的区别？"></a>Collections 和 collection的区别？</h1><p>答：Collections是用来操作集合的工具类，它是个类；collection是单列集合的顶层接口。</p>
<h1 id="栈和队列："><a href="#栈和队列：" class="headerlink" title="*栈和队列："></a>*栈和队列：</h1><p>队列结构：先进先出的规则<br>栈结构：先进后出规则</p>
<h1 id="链表和数组的区别："><a href="#链表和数组的区别：" class="headerlink" title="*链表和数组的区别："></a>*链表和数组的区别：</h1><p>数组：一块连续的存储区域<br>链表结构：每个元素指向下一个元素</p>
<h1 id="四、异常"><a href="#四、异常" class="headerlink" title="四、异常"></a>四、异常</h1><h1 id="异常体系概述？"><a href="#异常体系概述？" class="headerlink" title="异常体系概述？"></a>异常体系概述？</h1><p>答:Throwable类<br>        |–Error：无法通过处理解决的错误<br>        |–Exception：<br>            |–编译时异常:就是在编译程序生成.class文件时产生的异常,这种异常必须处理,要么抛出,要么捕获,否则编译无法通过<br>            |–运行时异常:编译时期不会出现,只有在运行时才产生,这种异常,可以处理,也可以不处理,可以声明,也可以不声明</p>
<h1 id="异常处理有哪些方式？"><a href="#异常处理有哪些方式？" class="headerlink" title="异常处理有哪些方式？"></a>异常处理有哪些方式？</h1><p>答（1）捕获处理try{}catch{}    try{}catch{}finally{}    try{}finally{}<br>（2）声明抛出</p>
<h1 id="运行异常和编译异常的区别？"><a href="#运行异常和编译异常的区别？" class="headerlink" title="运行异常和编译异常的区别？"></a>运行异常和编译异常的区别？</h1><p>答：所有的RumtimeException类及其子类的实例是运行异常，其他异常时编译异常。编译异常必须显式处理，否则会编译失败。运行时异常可以不处理，可以通过编译。</p>
<h1 id="throw和throws的区别？"><a href="#throw和throws的区别？" class="headerlink" title="throw和throws的区别？"></a>throw和throws的区别？</h1><p>答：throws是在方法声明后面，用来声明异常，后面跟的异常类名；可以跟多个异常类名，用逗号隔开；表示抛出异常，需要由调用者处理。<br>Throw定义在方法体内，跟的异常对象名；只能跟一个异常对象。</p>
<h1 id="子父类间异常的注意事项？"><a href="#子父类间异常的注意事项？" class="headerlink" title="子父类间异常的注意事项？"></a>子父类间异常的注意事项？</h1><p>答：（1）子类继承父类时，父类方法抛出了异常，子类重写该方法时只能抛出相同的异常或者该异常的子类。<br>（2）如果父类抛出了多个异常，子类在重写方法时只能抛出相同的异常或者他的子集，不能抛出父类没有的异常。<br>（3）如果父类没有抛出异常，子类重写该方法时不能抛出异常。如果子类出现了异常，只能进行try处理，不能抛出。</p>
<h1 id="异常处理的注意事项："><a href="#异常处理的注意事项：" class="headerlink" title="异常处理的注意事项："></a>异常处理的注意事项：</h1><p>（1）子类不能出现父类没有的异常<br>（2）如果父类没有抛出异常，子类重写该方法时不能抛出异常。如果子类出现了异常，只能进行try处理，不能抛出。<br>（3）功能内部如果出现异常，如果内部可以处理，就用try。如果功能内部处理不了，就必须声明出来，让调用者处理。</p>
<h1 id="JVM是如何处理异常的？"><a href="#JVM是如何处理异常的？" class="headerlink" title="JVM是如何处理异常的？"></a>JVM是如何处理异常的？</h1><p>先自己处理，处理不了交给调用者处理。</p>
<h1 id="五、IO"><a href="#五、IO" class="headerlink" title="五、IO"></a>五、IO</h1><h1 id="递归的注意事项？"><a href="#递归的注意事项？" class="headerlink" title="递归的注意事项？"></a>递归的注意事项？</h1><p>答：1.递归必须要有出口，否则是死递归，造成栈内存溢出。2.递归不能多层次调用，否则会造成栈内存溢出。3.构造方法不能递归调用。</p>
<h1 id="路径的分类？"><a href="#路径的分类？" class="headerlink" title="路径的分类？"></a>路径的分类？</h1><p>答：分为相对路径和绝对路径。绝对路径是相对盘符而言的；相对路径相对的是工程。</p>
<h1 id="集合的顶层是什么？IO的顶层是什么？"><a href="#集合的顶层是什么？IO的顶层是什么？" class="headerlink" title="集合的顶层是什么？IO的顶层是什么？"></a>集合的顶层是什么？IO的顶层是什么？</h1><p>答：集合的顶层是接口。IO的顶层的是抽象类。</p>
<h1 id="什么IO流？"><a href="#什么IO流？" class="headerlink" title="什么IO流？"></a>什么IO流？</h1><p>用来在硬盘和内存直接交换数据的。</p>
<h1 id="简述IO的分类？"><a href="#简述IO的分类？" class="headerlink" title="简述IO的分类？"></a>简述IO的分类？</h1><p>答：按照流向分输入流和输出流。<br>按照操作分为字节流和子字符流。<br>字节流能操作任意类型的文件，如果操作文本，可能会出现乱码。分为字节输出流和字节输入流。<br>字符流只能操作纯文本文件，分为字符输入流和字符输出流。</p>
<h1 id="为什么read（）方法返回值是int类型？"><a href="#为什么read（）方法返回值是int类型？" class="headerlink" title="为什么read（）方法返回值是int类型？"></a>为什么read（）方法返回值是int类型？</h1><p>答:为了防止中间出现11111111（-1的反码）这样的数据，后面的内容就读不到了。</p>
<h1 id="字符流通往字节流的桥梁是什么？字节流通往字符的桥梁是什么？"><a href="#字符流通往字节流的桥梁是什么？字节流通往字符的桥梁是什么？" class="headerlink" title="字符流通往字节流的桥梁是什么？字节流通往字符的桥梁是什么？"></a>字符流通往字节流的桥梁是什么？字节流通往字符的桥梁是什么？</h1><p>答：字符流通往字节流的桥梁是OutputStreamWriter；字节流通往字符流的桥梁是InputstreamReader。</p>
<h1 id="标准输入流和输出流是什么？"><a href="#标准输入流和输出流是什么？" class="headerlink" title="标准输入流和输出流是什么？"></a>标准输入流和输出流是什么？</h1><p>答：标准输入流的是System.in。标准输出流是System.out.</p>
<h1 id="高效字符流的方法？"><a href="#高效字符流的方法？" class="headerlink" title="高效字符流的方法？"></a>高效字符流的方法？</h1><p>ReadLine()读不到\r\n<br>newline()针对当前操作系统换行</p>
<h1 id="字节输入流read-一次读取的一个字节，返回的字节的对应的ASCII值。"><a href="#字节输入流read-一次读取的一个字节，返回的字节的对应的ASCII值。" class="headerlink" title="字节输入流read()一次读取的一个字节，返回的字节的对应的ASCII值。"></a>字节输入流read()一次读取的一个字节，返回的字节的对应的ASCII值。</h1><h1 id="字符缓冲流和字节缓冲流的缓冲区的默认大小是多少？"><a href="#字符缓冲流和字节缓冲流的缓冲区的默认大小是多少？" class="headerlink" title="字符缓冲流和字节缓冲流的缓冲区的默认大小是多少？"></a>字符缓冲流和字节缓冲流的缓冲区的默认大小是多少？</h1><p>答：字符缓冲流缓冲区默认的大小是8192个字符，16kb。<br>    字节缓冲流缓冲区默认的大小是8192个字节，8kb。<br>Writer的2kb。</p>
<h1 id="close（）和flush（）的区别："><a href="#close（）和flush（）的区别：" class="headerlink" title="close（）和flush（）的区别："></a>close（）和flush（）的区别：</h1><p>答：flush()方法是来刷新缓冲区的，刷新之后还可以再次写出。<br>Close()是用来关闭流释放资源的，如果是带缓冲区的流对象关闭流之前还会刷新缓冲区，关闭之后无法写出。</p>
<h1 id="六、网络编程"><a href="#六、网络编程" class="headerlink" title="六、网络编程"></a>六、网络编程</h1><h1 id="什么是网络编程？"><a href="#什么是网络编程？" class="headerlink" title="什么是网络编程？"></a>什么是网络编程？</h1><p>答：网络编程又叫套接字编程，Socket编程，就是用来实现网络互连的不同计算机上运行程序之间可以进行数据的交换。大白话来讲:就是用java语言来实现网络上不同计算机的通信。</p>
<h1 id="网络编程的三要素？"><a href="#网络编程的三要素？" class="headerlink" title="网络编程的三要素？"></a>网络编程的三要素？</h1><p>答：IP地址、端口、协议。<br>IP的组成网关和主机地址。127.0.0.1回环地址   255.255.255.255广播地址</p>
<h1 id="端口的范围是什么？哪个范围的端口不能用，为什么？"><a href="#端口的范围是什么？哪个范围的端口不能用，为什么？" class="headerlink" title="端口的范围是什么？哪个范围的端口不能用，为什么？"></a>端口的范围是什么？哪个范围的端口不能用，为什么？</h1><p>答：端口的范围是0——65535.   0——1024这个范围的端口不能使用，因为已经被系统占用或者作为保留端口。</p>
<h1 id="TCP和UDP协议的区别？"><a href="#TCP和UDP协议的区别？" class="headerlink" title="TCP和UDP协议的区别？"></a>TCP和UDP协议的区别？</h1><p>答：TCP是面向有连接的，三次握手机制；传输的数据无大小限制；安全（可靠）协议；效率低；区分客户端和服务器。<br>UDP是面向无连接的，发送的数据是通过数据报包的形式，不超过64k；不安全（可靠）协议，效率高；不区分客户端和服务器。（叫发送端和接收端）</p>
<h1 id="Socket通信的原理是是什么？"><a href="#Socket通信的原理是是什么？" class="headerlink" title="Socket通信的原理是是什么？"></a>Socket通信的原理是是什么？</h1><p>答：通信的两端都有独有的Socket，Socket通信就是使用TCP或者UDP协议通过IO流在两个Socket间进行通信。</p>
<h1 id="七、多线程"><a href="#七、多线程" class="headerlink" title="七、多线程"></a>七、多线程</h1><h1 id="继承和线程？"><a href="#继承和线程？" class="headerlink" title="继承和线程？"></a>继承和线程？</h1><p>进程是一个正在执行中的程序，每一个程序都至少有一个执行顺序，该顺序是一个路径，或者叫一个控制单元。<br>线程是进程中的一个独立的控制单元，线程在控制着进程的执行，是进程的执行路径。<br>进程：正在运行的程序<br>线程：进程的执行单元，执行路径。<br>多线程：进程有多条执行路径，每个执行路径就是线程。</p>
<h1 id="多线程并发和多线程并行是什么呢"><a href="#多线程并发和多线程并行是什么呢" class="headerlink" title="多线程并发和多线程并行是什么呢?"></a>多线程并发和多线程并行是什么呢?</h1><p>答：两个或者多个任务发送请求时，CPU只能执行一个，就会安排这些任务交替执行，由于CPU做着高速的切换，间隔的时间比较短，我们看起来像同时执行的，这就是多线程并发。<br>并行是两个或多个任务同时执行，前提是多核CPU。</p>
<h1 id="多线程的执行原理？"><a href="#多线程的执行原理？" class="headerlink" title="多线程的执行原理？"></a>多线程的执行原理？</h1><p>答： CPU在做着高速的切换。</p>
<h1 id="线程的执行具有随机性和延迟性。"><a href="#线程的执行具有随机性和延迟性。" class="headerlink" title="线程的执行具有随机性和延迟性。"></a>线程的执行具有随机性和延迟性。</h1><h1 id="线程的默认命名规则？"><a href="#线程的默认命名规则？" class="headerlink" title="线程的默认命名规则？"></a>线程的默认命名规则？</h1><p>答：Thread-编号，编号是从0开始的。</p>
<h1 id="线程的优先级的范围是多少？默认的优先级是？"><a href="#线程的优先级的范围是多少？默认的优先级是？" class="headerlink" title="线程的优先级的范围是多少？默认的优先级是？"></a>线程的优先级的范围是多少？默认的优先级是？</h1><p>答：线程的优先级范围是1——10。默认的优先级是5.</p>
<h1 id="Java程序的启动原理？"><a href="#Java程序的启动原理？" class="headerlink" title="Java程序的启动原理？"></a>Java程序的启动原理？</h1><p>答：JVM启动一个主线程，再由主线程调用某个类的main方法。</p>
<h1 id="Java程序是多线程的吗？"><a href="#Java程序是多线程的吗？" class="headerlink" title="Java程序是多线程的吗？"></a>Java程序是多线程的吗？</h1><p>答：是的，至少开启了一个主线程和负责垃圾回收的线程。</p>
<h1 id="线程的优先级越高，代表这个线程一定是第一个执行的吗？"><a href="#线程的优先级越高，代表这个线程一定是第一个执行的吗？" class="headerlink" title="线程的优先级越高，代表这个线程一定是第一个执行的吗？"></a>线程的优先级越高，代表这个线程一定是第一个执行的吗？</h1><p>答：不是的，线程的优先级越高代表着在一定程度上让该线程获取更多的执行机会。</p>
<h1 id="线程的两种实现-方式的区别？"><a href="#线程的两种实现-方式的区别？" class="headerlink" title="线程的两种实现 方式的区别？"></a>线程的两种实现 方式的区别？</h1><p>答：继承Thread类：好处是：因为是继承，代码简单，能够直接使用Thread类的方法。确定是：扩展性比较差，因为继承了Thread类，不能再继承其他的类。<br>实现Runnable接口：好处是扩展性比较强。缺点时：代码比较冗余，因为不是继承Thread类，无法直接使用thread中的方法。</p>
<h1 id="同步代码块和同步方法的锁是谁？"><a href="#同步代码块和同步方法的锁是谁？" class="headerlink" title="同步代码块和同步方法的锁是谁？"></a>同步代码块和同步方法的锁是谁？</h1><p>答;同步代码块的锁可以是任意类型的对象；非静态同步方法的锁是this；静态方法的锁是该类的字节码文件。</p>
<h1 id="实现Runnable和Callable的区别？"><a href="#实现Runnable和Callable的区别？" class="headerlink" title="实现Runnable和Callable的区别？"></a>实现Runnable和Callable的区别？</h1><p>答：实现Runnable接口的run方法没有返回值，不能抛异常；而实现Callable接口的call方法可以抛异常，有返回值。<br>Runnable接口的实现类对象既可以作为参数传递给Thread的构造方法，也可以用线程池submit的参数；Callable接口的实现类对象只适应于线程池。</p>
<h1 id="线程的生命周期（线程的五种状态）是什么？"><a href="#线程的生命周期（线程的五种状态）是什么？" class="headerlink" title="线程的生命周期（线程的五种状态）是什么？"></a>线程的生命周期（线程的五种状态）是什么？</h1><p>答：新建、就绪、运行（运行的时候可能阻塞）、死亡。<br>线程的六种状态：新建、就绪、运行（运行的时候可能阻塞或者等待）、死亡。</p>
<h1 id="sleep和wait的区别？"><a href="#sleep和wait的区别？" class="headerlink" title="sleep和wait的区别？"></a>sleep和wait的区别？</h1><p>答：（1）sleep是让线程睡眠，必须给相应的睡眠时间，不需要唤醒，时间到了会自动醒来，休眠时不放弃Cpu的执行权。<br>（2）wait的是让线程等待，可以传参也可以不传参，传参是在指定的时间后等待，需要被唤醒。等待的时候放弃cpu的执行权。</p>
<h1 id="什么时候会出现安全性？"><a href="#什么时候会出现安全性？" class="headerlink" title="什么时候会出现安全性？"></a>什么时候会出现安全性？</h1><p>多线程，并发，操作同一数据。</p>
<h1 id="为什么wait-和notify-定义在Object中？"><a href="#为什么wait-和notify-定义在Object中？" class="headerlink" title="为什么wait()和notify()定义在Object中？"></a>为什么wait()和notify()定义在Object中？</h1><p>答：因为锁对象可以是任意类型的对象。</p>
<h1 id="什么情况下需要同步？"><a href="#什么情况下需要同步？" class="headerlink" title="什么情况下需要同步？"></a>什么情况下需要同步？</h1><p>当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.<br>如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.</p>
<h1 id="八、模拟汤姆猫服务器"><a href="#八、模拟汤姆猫服务器" class="headerlink" title="八、模拟汤姆猫服务器"></a>八、模拟汤姆猫服务器</h1><p>150.BS结构和CS的区别？<br>答：CS结构是指客户端和服务器端，开发比较容易，因为用户的应用程序都在客户端，降低了系统通压力，但是维护比较困难。<br>BS结构是指浏览器服务器端，开发比较困难，因为应用程序基本都在服务器端，维护比较方便。</p>
<h1 id="静态资源和动态资源是什么？"><a href="#静态资源和动态资源是什么？" class="headerlink" title="静态资源和动态资源是什么？"></a>静态资源和动态资源是什么？</h1><p>答：静态资源是Web页面给人们看到的数据是始终不变的，例如html。<br>动态资源是Web页面给人们看的数据是系统自动生成的，随时变化的。例如JSP/Servlet、ASP、PHP<br>在JAVA，动态Web资源开发技术通称Javaweb。</p>
<h1 id="常用的状态码你知道哪些？"><a href="#常用的状态码你知道哪些？" class="headerlink" title="常用的状态码你知道哪些？"></a>常用的状态码你知道哪些？</h1><p>答：200  请求成功；404  请求的资源不存在；500  服务器发生未知的错误。</p>
<h1 id="GET请求和POST请求的区别？"><a href="#GET请求和POST请求的区别？" class="headerlink" title="GET请求和POST请求的区别？"></a>GET请求和POST请求的区别？</h1><p>答：GET请求会将请求信息置于地址栏，不安全，适合小数据的传输。<br>POST请求将请求信息置于请求体，相对安全，适合大数据的传输。</p>
<h1 id="客户端向服务器发送请求request，服务器对客户端的请求做出响应response。"><a href="#客户端向服务器发送请求request，服务器对客户端的请求做出响应response。" class="headerlink" title="客户端向服务器发送请求request，服务器对客户端的请求做出响应response。"></a>客户端向服务器发送请求request，服务器对客户端的请求做出响应response。</h1><p>http协议是互联网的通用协议（规则），客户端和服务端都要遵循这个协议。默认端口号是80.</p>
<h1 id="请求信息包括什么？响应信息包括什么？"><a href="#请求信息包括什么？响应信息包括什么？" class="headerlink" title="请求信息包括什么？响应信息包括什么？"></a>请求信息包括什么？响应信息包括什么？</h1><p>答：请求头和请求体。请求头又包括请求行和头信息。<br>响应信息包括响应头和响应体。</p>
<h1 id="九．数据库"><a href="#九．数据库" class="headerlink" title="九．数据库"></a>九．数据库</h1><h1 id="为什么要有数据库？常见的数据你知道哪些？"><a href="#为什么要有数据库？常见的数据你知道哪些？" class="headerlink" title="为什么要有数据库？常见的数据你知道哪些？"></a>为什么要有数据库？常见的数据你知道哪些？</h1><p>答：为了永久存储数据，并且能够操作数据。<br>MySQL  SQL Server  Oracle</p>
<h1 id="数据库的本质是什么"><a href="#数据库的本质是什么" class="headerlink" title="数据库的本质是什么?"></a>数据库的本质是什么?</h1><p>答;数据库的本质是一个文件系统。</p>
<h1 id="数据库以什么为单位存储数据？"><a href="#数据库以什么为单位存储数据？" class="headerlink" title="数据库以什么为单位存储数据？"></a>数据库以什么为单位存储数据？</h1><p>数据库中以表为组织单位存储数据。</p>
<h1 id="常用的SQL语句？"><a href="#常用的SQL语句？" class="headerlink" title="常用的SQL语句？"></a>常用的SQL语句？</h1><p>create  database 数据库名;     创建数据库<br>show databases;                查看所有数据库<br>use 数据库名；                 使用指定数据库<br>create table 表名（            创建表<br>列名1  数据类型 约束，<br>列名2  数据类型，<br>列名3  数据类型，<br>…<br>列名n  数据类型    –不加，<br> ）<br>insert into 表名（列名1，列名2，.列名n） values （值1，值2…）;添加数据<br>delete from 表名 where 条件       删除指定条件的数据<br>update 表名 set 字端1 = 值1，字端2=值2  where 条件； 修改指定数据<br>select 字段1,字段2,…from 表名;      按照表中的字段名查询：<br>select * from 表名;                       查询表中所有字段  </p>
<p>order by   排序<br>group by   分组：</p>
<h1 id="聚合函数？"><a href="#聚合函数？" class="headerlink" title="聚合函数？"></a>聚合函数？</h1><p>count、sum、max、min、avg</p>
<h1 id="JDBC的核心功能是什么？"><a href="#JDBC的核心功能是什么？" class="headerlink" title="JDBC的核心功能是什么？"></a>JDBC的核心功能是什么？</h1><p>答：连接数据库；向数据库发送SQL语句；操作SQL语句的返回结果。</p>
<h1 id="DBUtils能否创建数据库和表？"><a href="#DBUtils能否创建数据库和表？" class="headerlink" title="DBUtils能否创建数据库和表？"></a>DBUtils能否创建数据库和表？</h1><p>答：不能，只能操作数据库里面的数据。</p>
<h1 id="SQL语言的分类？"><a href="#SQL语言的分类？" class="headerlink" title="SQL语言的分类？"></a>SQL语言的分类？</h1><p>答：SQL语言是JAVA操作数据库的语言。分为DDL（Data Definition Language）数据定义语言；DML（Data manipulation Language）数据操作语言(增删覆盖)；DCL（Data Control Language）数据控制语言；DQL(Data Query Language)数据查询语言。</p>
<h1 id="SQL注入的问题产生原因和解决方法？"><a href="#SQL注入的问题产生原因和解决方法？" class="headerlink" title="SQL注入的问题产生原因和解决方法？"></a>SQL注入的问题产生原因和解决方法？</h1><p>答：SQL注入是因为客户输入的是SQL语句。可以使用PreparedStatement接口的子类对象。</p>
<h1 id="连接池？"><a href="#连接池？" class="headerlink" title="连接池？"></a>连接池？</h1><p>答：数据库连接的建立和关闭都是极其消耗资源的。数据库连接池的解决方案是当应用程序启动时，系统主动创建足够的数据库连接，并将这些连接组成一个连接池，每次使用的时候无序重新创建联系，直接从连接池中取出已有的连接使用，使用完后不再关闭数据库连接，而是直接归还到连接池。通过连接池，将极大的提高了程序的运行效率。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC]]></title>
      <url>http://xiaoweiwei.space/2016/03/10/springmvc/</url>
      <content type="html"><![CDATA[<p><img src="http://ol64dqiw0.bkt.clouddn.com/u=2017075320,981963636&amp;fm=23&amp;gp=0.jpg" alt=""><br><a id="more"></a></p>
<h1 id="什么是springMvc"><a href="#什么是springMvc" class="headerlink" title="什么是springMvc"></a>什么是springMvc</h1><p> springmvc是一个表现层框架,是spring公司出品</p>
<h1 id="springmvc作用"><a href="#springmvc作用" class="headerlink" title="springmvc作用"></a>springmvc作用</h1><p>  a)从请求中接受参数<br>  b)将处理好的数据返回给页面</p>
<h1 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h1><p>  springmvc简单执行流程<br>  1-tomcat启动后会自动加载web项目中的web.xml文件<br>  2-然后加载web,xml中的dispatcherservlet<br>  3-接下来加载dispatcherservlet中的springMvc.xml文件,加载springMvc.xml开启注解扫描的配置.<br>  4-然后会将controller包下面的所有的类都加载一遍将有@controller注解的加载到内存中<br>  5-会将$ResourceMapping(“/list”)中的lidt当成key,将下面要执行的方法对象当成value也加载到内存中<br>  6-如果浏览器访问localhost:8080/springmvc/list.action就会找到内存中的对应的key和对应的value去执行</p>
<h1 id="springMvc三大组件-处理器映射器-处理器视配器-视图解析器"><a href="#springMvc三大组件-处理器映射器-处理器视配器-视图解析器" class="headerlink" title="springMvc三大组件 #:处理器映射器,处理器视配器,视图解析器."></a>springMvc三大组件 #:处理器映射器,处理器视配器,视图解析器.</h1><p>需要程序员写的组件handler(controller)处理器,视图(jsp)</p>
<h1 id="注解驱动的作用"><a href="#注解驱动的作用" class="headerlink" title="注解驱动的作用"></a>注解驱动的作用</h1><p>如果我们没有显示的配置处理器映射器和处理器适配器.那么 默认的springMvc每个请求进来都会去找默认的配置文件dispatcherServlet.poperties配置文件k,去里面的处理器映射器和处理器适配器列表,进行一一对比,来找到合适类型的处理器砚器和处理器适配器去执行这样就会大大降低系统的效率,所以需要我们显示的配置处理器映射器和处理器适配器</p>
<h1 id="spring-springmvc-mybatis整合"><a href="#spring-springmvc-mybatis整合" class="headerlink" title="spring+springmvc+mybatis整合"></a>spring+springmvc+mybatis整合</h1><p>1-dao层<br>    sqlMapConfig.xml   mybatis核心配置文件,配置任何东西,但是必须有<br>2-service层<br>    applicationContext-service.xml<br>    applicationContext-trans.xml<br>3-controller层<br>    springmvc.xml @controller注解扫描  注解驱动  视图解析器<br>4-web.xml<br>    spring配置加载所有spring配置文件.<br>    springmvc前端控制器dispatcherservlet加载springmvc.xml</p>
<h1 id="参数绑定-从请求中接收参数"><a href="#参数绑定-从请求中接收参数" class="headerlink" title="参数绑定(从请求中接收参数)"></a>参数绑定(从请求中接收参数)</h1><p>   1.默认支持的参数类型:request response session model<br>接收参数时可以加也可以不加.看自己 需要,model模型,可以在接收参数时加上,用它来返回页面数据<br>   2.简单数据类型:string  integer  double  boolean等<br>要求controller方法接收的战术的名称必须等于页面input框的name属性值<br>   3.pojo<br>要求:页面上input框的属性值必须等于pojo中的属性名称<br>   4-pojo类的包装类queryvo<br>要求:如果传入对象是queryvo,那么页面input框的name属性值必须是vo中的属性.属性.属性….<br>   5-转换器converter<br>springMvc不能将字符串自动转换成日期,所以需要我们手动进行类型转换<br>转换器作用:可以在springMvc的controller犯法接收参数之前做数据的统一的处理<br>面试题;springmvc中注解驱动和注解扫描有什么区别,用不用都配置;</p>
<p>–都要配置,<br>注解驱动的作用是代替我们显示的配置最新版的注解形式的处理器映射器和处理器适配器.<br>注解扫描,是要开启@controller注解,所以两个东西没有任何关系.</p>
<p>@autowared在一个接口有一个实现类的时候可以自动注入<br>当一个接口如果有多个实现类,可以给@service(“xxx”)起个名,<br>然后注入的时候</p>
<h1 id="springMvc和structs区别"><a href="#springMvc和structs区别" class="headerlink" title="springMvc和structs区别"></a>springMvc和structs区别</h1><p>structs:<br>前端控制器是structsPrepareAndExcuteFilter<br>接收参数:模型驱动就是用全局的成员变量来接收参数,由于全局类型的成员变量线程是不安全的,所以action必须是多例</p>
<p>数据返回页面:用的是值栈</p>
<p>sprinfMvc;<br>前端控制器是dispatcherServlet<br>接收:使用方法级别的,局部变量来接收参数,因为局部变量用完就销毁,所以线程安全,所以springmvc中的controller是单例</p>
<p>数据返回给页面:用的request域.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[lucene全文检索引擎]]></title>
      <url>http://xiaoweiwei.space/2015/12/22/lucene/</url>
      <content type="html"><![CDATA[<p><img src="http://ol64dqiw0.bkt.clouddn.com/lucene.jpg" alt=""><br>Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支    持和提供<br>Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻，    在Java开发环境里Lucene是一个成熟的免费开放源代码工具<br>Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品<br><a id="more"></a><br>官网： <a href="http://lucene.apache.org/" target="_blank" rel="external">http://lucene.apache.org/</a> </p>
<h1 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类:"></a>数据的分类:</h1><p>结构化数据: 就是有固定类型或者是长度的数据<br>例如: 数据库中的数据<br>搜索方式: 数据库中的数据使用sql语句来搜索<br>非结构化数据: 没有固定长度和类型的数据<br>例如: world中的数据, txt中的数据, 邮件中的数据<br>搜索方式: ctrl+f来搜索</p>
<h1 id="搜索数据的算法"><a href="#搜索数据的算法" class="headerlink" title="搜索数据的算法:"></a>搜索数据的算法:</h1><p>顺序扫描法: 拿着所要搜索的关键字去文档中查找, 从文件头开始逐字匹配查找, 直到找到为止<br>优点: 如果文件中有关键字, 那么指定能查找到<br>缺点: 慢, 非常慢, 随着数据越多, 速度越慢<br>比如: 在写sql语句的时候使用的模糊查询关键字 like就是使用顺序扫描法</p>
<h1 id="全文检索算法-倒排索引表算法"><a href="#全文检索算法-倒排索引表算法" class="headerlink" title="全文检索算法(倒排索引表算法):"></a>全文检索算法(倒排索引表算法):</h1><p>将源文件的内容读取出来, 进行切分词, 然后将一个一个的词, 组成索引(目录),<br>查询的时候先查询索引(目录), 通过索引来找文档, 那么这种过程就叫做全文检索<br>优点: 快, 不会随着数据的增大, 而减少查询速度<br>缺点: 额外占用了磁盘空间, 因为要把源文件拿出来组成目录, 目录就是额外占用的磁盘空间<br>全文检索算法是用空间换时间</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释:"></a>名词解释:</h1><p>切分词: 去掉空格,去掉标点符号, 去掉停用词(的,地,得, a, an, the), 大写字母转小写字母, 将一句话切分成一个一个的单词<br>索引库: lucene中用来保存索引和文档位置的文件夹叫做索引库<br>term词元: 就是一个单词</p>
<h1 id="lucene是什么"><a href="#lucene是什么" class="headerlink" title="lucene是什么"></a>lucene是什么</h1><p>lucene是apache组织的一个全文检索引擎工具包. 就是一堆jar包. </p>
<h1 id="lucene有什么用"><a href="#lucene有什么用" class="headerlink" title="lucene有什么用"></a>lucene有什么用</h1><p>我们可以使用lucene来创建像百度,谷歌这样的全文检索引擎系统.</p>
<h1 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域:"></a>应用领域:</h1><p>a) 互联网全文检索引擎: 百度, 谷歌, 必应等<br>b) 站内全文检索: 京东, 天猫搜索商品,   贴吧中搜索帖子等</p>
<h1 id="分词器"><a href="#分词器" class="headerlink" title="分词器:"></a>分词器:</h1><p>cjk分词器的算法是二分法.分词效果不好.<br>IK分词器: 支持中文的语法分析<br>停用词典作用: 出现在停用词典中的词, 不会出现在索引中, 都会被干掉<br>扩展词典: 出现在扩展词典中的词, 就是一个词, 一般把公司名称等专有名词放入其中</p>
<p>注意: ik分词刚解压后, 扩展词典和停用词典中的文件编码是错误的放入项目中是不好用的,<br>所以需要我们手动将原来的utf-8+BOM编码格式另存为utf-8格式才可以使用</p>
<h1 id="tomcat-jboss区别"><a href="#tomcat-jboss区别" class="headerlink" title="tomcat jboss区别?"></a>tomcat jboss区别?</h1><p>jboss  J2EE容器<br>tomcat   web容器</p>
<p>Tomcat：是Java开发的一个符合JavaEE的Servlet规范的JSP服务器（Servlet容器），是 Apache 的扩展</p>
<p>特性：免费的Java应用服务器</p>
<p>1、主要用于解析JSP/Servlet，侧重于Servlet引擎；</p>
<p>2、支持静态页，但效率没有Apache高；支持Servlet、JSP请求；</p>
<p>3、Tomcat本身也内置了一个HTTP服务器用于支持静态内容，可以通过Tomcat的配置管理工具实现与Apache整合。</p>
<p>Jboss  ：应用服务器，运行EJB的J2EE应用服务器，遵循J2EE规范，能够提供更多平台的支持和更多集成功能，如数据库连接，<br>JCA等；其对servlet的支持是通过集成其他servlet容器来实现的，如tomcat和jetty；<br>1、JBoss是免费的，开放源代码J2EE的实现，它通过LGPL许可证进行发布。<br>2、JBoss需要的内存和硬盘空间比较小。<br>3、安装非常简单。先解压缩JBoss打包文件再配置一些环境变量就可以了。<br>4、JBoss能够”热部署”，部署BEAN只是简单拷贝BEAN的JAR文件到部署路径下就可以了。如果没有加载就加载它；如果已经加载了就卸载掉，然后LOAD这个新的。<br>5、JBoss与Web服务器在同一个Java虚拟机中运行，Servlet调用EJB不经过网络，从而大大提高运行效率，提升安全性能。<br>6、用户可以直接实施J2EE-EAR，而不是以前分别实施EJB-JAR和Web-WAR，非常方便。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人总结]]></title>
      <url>http://xiaoweiwei.space/2015/07/09/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="aop是什么-项目中怎么用"><a href="#aop是什么-项目中怎么用" class="headerlink" title="aop是什么   项目中怎么用"></a>aop是什么   项目中怎么用</h1><p>aop是面向切面编程，利用aop可以对业务逻辑的各个部分进行隔离，从而使各个业务之间的耦合性降低，提高重用性  同时提高了开发的效率。<br>是OOP扩展和延伸，解决OOP中一些问题而出现。AOP采用叫做横向抽取机制取代传统方式纵向继承体系对程序扩展和延伸。<br>在具体的项目中，我们可以在不修改代码的情况下，对程序进行扩展 可以用于对用户的权限校验  日志记录  性能检测  </p>
<p>Springaop  的底层是动态代理  jdk动态代理  和cglib 动态代理</p>
<a id="more"></a>
<h1 id="sql-优化-平时你注意过那些方面"><a href="#sql-优化-平时你注意过那些方面" class="headerlink" title="sql 优化  平时你注意过那些方面"></a>sql 优化  平时你注意过那些方面</h1><p> 1对关键的字段建立索引<br> 2select子句中避免使用<br> 3尽量使用count<br> 4选择记录条数最少的表作为基础表<br>  in 代替or  </p>
<h1 id="Struts2-和SpringMVC有什么区别"><a href="#Struts2-和SpringMVC有什么区别" class="headerlink" title="Struts2  和SpringMVC有什么区别"></a>Struts2  和SpringMVC有什么区别</h1><p>springMvc和struts2区别:<br>struts2:<br>    a)struts2的核心控制器是filter<br>    b)接收参数: struts2使用全局类型的成员变量来接收参数,由于全局类型的成员变量是线程不安全,<br>        所以stuts2的action需要配置成多例<br>    c)返回数据: struts2使用值栈</p>
<p>springMvc:<br>    a)springMvc核心控制器是servlet<br>    b)接收参数: springMvc采用方法级别的局部变量来接收参数, 局部变量用完就销毁, 所以线程安全,<br>        所以springMvc的controller是单例的<br>    c)返回数据: springMvc使用request域</p>
<h1 id="hibernate-和mybatis有什么区别"><a href="#hibernate-和mybatis有什么区别" class="headerlink" title="hibernate 和mybatis有什么区别"></a>hibernate 和mybatis有什么区别</h1><p>hibernate和mybatis区别:<br>        hibernate: hibernate是一个orm框架, 需要编写hql语句, 自动化程度高, 但是学习成本也要, 使用复杂<br>        但是写代码效率高, 开发速度快.<br>        使用场景: 一般外包公司使用较多, 因为开发速度快. 一些传统项目也在用, oa, crm, erp</p>
<pre><code> mybatis: mybatis不是一个完全的orm框架, 需要编写sql语句, 学习成本低, 比较简单.
使用场景: 在互联网企业用用的都, 电商, 互联网金融等
</code></pre><h1 id="查看tomcat日志的linux命令是什么"><a href="#查看tomcat日志的linux命令是什么" class="headerlink" title="查看tomcat日志的linux命令是什么"></a>查看tomcat日志的linux命令是什么</h1><p>  查看运行日志  tail -f catalina.out<br>  查看最近50行日志  tail -n 50 -f catalina.out<br>  catalina.out  文件在tomcat文件夹下  logs 文件夹下</p>
<h1 id="怎么理解多态"><a href="#怎么理解多态" class="headerlink" title="怎么理解多态"></a>怎么理解多态</h1><p>多态是java面向对象思想的一种特性</p>
<p>从字面上理解为 一个类表现出多种的形态 他是一种编程技巧 而不是写代码的格式或者方式<br>子类继承父类的时候 同时继承子类的方法<br>多态的三要素</p>
<p>继承  方法重写  父类引用指向子类对象</p>
<h1 id="redis怎么存储对象"><a href="#redis怎么存储对象" class="headerlink" title="redis怎么存储对象"></a>redis怎么存储对象</h1><p>把对象序列化</p>
<p>jeson util</p>
<p>redis存储对象<br>五大类型</p>
<p>String<br>list<br>set<br>sortedset<br>hashmap</p>
<h1 id="怎么实现系统错误日志记录"><a href="#怎么实现系统错误日志记录" class="headerlink" title="怎么实现系统错误日志记录"></a>怎么实现系统错误日志记录</h1><pre><code>写一个全局的异常处理系统，出现系统错误的时候，面向用户  跳转指定的页面  并且记录错误的日志信息
</code></pre><p>记录日志信息的是log4j<br>具体的配置  按照文档配置</p>
<pre><code>a.导入jar包
b. 在classpath下 新建log4g.properties
c.然后再写log.java
</code></pre><h1 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h1><h1 id="消息推送"><a href="#消息推送" class="headerlink" title="消息推送"></a>消息推送</h1><p>amq<br>消息队列<br>java message service </p>
<p>点对点模式  私聊<br>发布者 订阅者模式  群聊</p>
<h1 id="怎么实现负载均衡"><a href="#怎么实现负载均衡" class="headerlink" title="怎么实现负载均衡"></a>怎么实现负载均衡</h1><p>利用nginx  实现负载均衡</p>
<p>nginx  是一个高性能的http服务器  和反向代理服务器  </p>
<p>三种负载均衡策略</p>
<p>轮询<br>最少连接<br>ip哈希<br>权重</p>
<h1 id="负载后怎么实现session共享"><a href="#负载后怎么实现session共享" class="headerlink" title="负载后怎么实现session共享"></a>负载后怎么实现session共享</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我喜欢你很久了]]></title>
      <url>http://xiaoweiwei.space/2015/06/10/%E6%88%91%E5%96%9C%E6%AC%A2%E4%BD%A0%E5%BE%88%E4%B9%85%E4%BA%86/</url>
      <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/005vGbJ7jw1f671ikpgnhj30s20as0v3.jpg" alt=""><br><a id="more"></a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=229010&auto=1&height=66"></iframe>


]]></content>
    </entry>
    
  
  
</search>
